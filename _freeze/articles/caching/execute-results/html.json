{
  "hash": "414932776bfa718f566424194c3e34c5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Caching results\"\nexecute:\n  eval: true\n  freeze: true\n---\n\n\n\nData preparation, and model preparation, is usually a iterative process. Because\nmodels in R are normally rather fast,   it is not a problem to re-run the\nentire code to confirm that all of the results are reproducible. But in\nthe case of LLM's, re-running things may be a problem. Locally, running the \nLLM will be processor intensive, and typically long. If running against a remote\nLLM, the issue would the cost per token. \n\nTo ameliorate this, `mall` is able to cache existing results in a folder. That way, \nrunning the same analysis over and over, will be much quicker. Because instead of\ncalling the LLM again, `mall` will return the previously recorded result. \n\nBy default, this functionality is turned on. The results will be saved to a folder\nnamed \"_mall_cache\" . The name of the folder can be easily changed, simply set\nthe `.cache` argument in `llm_use()`. To **disable** this functionality, set\nthe argument to an empty character, meaning `.cache = \"\"`.\n\n## How it works\n\n`mall` uses all of the values used to make the LLM query as the \"finger print\"\nto confidently identify when the same query is being done again. This includes:\n\n- The value in the particular row\n- The additional prompting built by the `llm_` function,\n- Any other arguments/options used, set in `llm_use()`\n- The name of the back end used for the call\n\nA file is created that contains the request and response. The key to the process\nis the name of the file itself. The name is the hashed value of the combined\nvalue of the items listed above. This becomes the \"finger print\" that allows \n`mall` to know if there is an existing cache. \n\n## Walk-through \n\nWe will initialize the LLM session specifying a seed\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mall)\n\nllm_use(\"ollama\", \"llama3.2\", seed = 100, .cache = \"_mall_cache\")\n#> \n#> ── mall session object\n#> Backend: ollama\n#> LLM session:\n#>   model:llama3.2\n#> \n#>   seed:100\n#> \n#> R session: cache_folder:_mall_cache\n```\n:::\n\n\nUsing the `tictoc` package, we will measure how long it takes to make a simple\nsentiment call. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tictoc)\n\ntic()\nllm_vec_sentiment(\"I am happy\")\n#> [1] \"positive\"\ntoc()\n#> 0.318 sec elapsed\n```\n:::\n\n\nThis creates a the \"_mall_cache\" folder, and inside a sub-folder, it creates a \nfile with the cache. The name of the file is the resulting hash value of the\ncombination mentioned in the previous section. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir_ls(\"_mall_cache\", recurse = TRUE, type = \"file\")\n#> _mall_cache/78/7863b5af515b487e8ea7ba8f4d9330bb.json\n```\n:::\n\n\nThe cache is a JSON file, that contains both the request, and the response. As\nmentioned in the previous section, the named of the file is derived from the\ncombining the values in the request (`$request`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\njsonlite::read_json(\n  \"_mall_cache/78/7863b5af515b487e8ea7ba8f4d9330bb.json\",\n  simplifyVector = TRUE,\n  flatten = TRUE\n)\n#> $request\n#> $request$messages\n#>   role\n#> 1 user\n#>                                                                                                                                                                                                 content\n#> 1 You are a helpful sentiment engine. Return only one of the following answers: positive, negative, neutral. No capitalization. No explanations. The answer is based on the following text:\\nI am happy\n#> \n#> $request$output\n#> [1] \"text\"\n#> \n#> $request$model\n#> [1] \"llama3.2\"\n#> \n#> $request$seed\n#> [1] 100\n#> \n#> \n#> $response\n#> [1] \"positive\"\n```\n:::\n\n\nRe-running the same `mall` call, will complete significantly faster\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntic()\nllm_vec_sentiment(\"I am happy\")\n#> [1] \"positive\"\ntoc()\n#> 0.002 sec elapsed\n```\n:::\n\n\nIf a slightly different query is made, `mall` will recognize that this is a\ndifferent call, and it will send it to the LLM. The results are then saved in a \nnew JSON file. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nllm_vec_sentiment(\"I am very happy\")\n#> [1] \"positive\"\n\ndir_ls(\"_mall_cache\", recurse = TRUE, type = \"file\")\n#> _mall_cache/22/22dbf531e945c3ca4dcb6caf5ace383a.json\n#> _mall_cache/78/7863b5af515b487e8ea7ba8f4d9330bb.json\n```\n:::\n\n\nDuring the same R session, if we change something in `llm_use()` that will\nimpact the request to the LLM, that will trigger a new cache file\n\n\n::: {.cell}\n\n```{.r .cell-code}\nllm_use(seed = 101)\n#> \n#> ── mall session object\n#> Backend: ollama\n#> LLM session:\n#>   model:llama3.2\n#> \n#>   seed:101\n#> \n#> R session: cache_folder:_mall_cache\n\nllm_vec_sentiment(\"I am very happy\")\n#> [1] \"positive\"\n\ndir_ls(\"_mall_cache\", recurse = TRUE, type = \"file\")\n#> _mall_cache/22/22dbf531e945c3ca4dcb6caf5ace383a.json\n#> _mall_cache/78/7863b5af515b487e8ea7ba8f4d9330bb.json\n#> _mall_cache/e6/e6913e9b46ad7af7e2dad693a8e8ddac.json\n```\n:::\n\n\nThe only argument that does not trigger a new cache file is `.silent`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nllm_use(seed = 101, .silent = TRUE)\n\nllm_vec_sentiment(\"I am very happy\")\n#> [1] \"positive\"\n\ndir_ls(\"_mall_cache\", recurse = TRUE, type = \"file\")\n#> _mall_cache/22/22dbf531e945c3ca4dcb6caf5ace383a.json\n#> _mall_cache/78/7863b5af515b487e8ea7ba8f4d9330bb.json\n#> _mall_cache/e6/e6913e9b46ad7af7e2dad693a8e8ddac.json\n```\n:::\n\n\n## Performance improvements \n\nTo drive home the point of the usefulness of this feature, we will use the\nsame data set we used for the README. To start, we will change the cache folder\nto make it easy to track the new files\n\n\n::: {.cell}\n\n```{.r .cell-code}\nllm_use(.cache = \"_performance_cache\", .silent = TRUE)\n```\n:::\n\nAs mentioned, we will use the `data_bookReviews` data frame from the `classmap`\npackage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(classmap)\n\ndata(data_bookReviews)\n```\n:::\n\n\nThe individual reviews in this data set are really long. So they take a while to\nprocess. To run this test, we will use the first 5 rows: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntic()\n\ndata_bookReviews |>\n  head(5) |>\n  llm_sentiment(review)\n#> # A tibble: 5 × 3\n#>   review                                        sentiment .sentiment\n#>   <chr>                                         <fct>     <chr>     \n#> 1 \"i got this as both a book and an audio file… 1         negative  \n#> 2 \"this book places too much emphasis on spend… 1         negative  \n#> 3 \"remember the hollywood blacklist? the holly… 2         positive  \n#> 4 \"while i appreciate what tipler was attempti… 1         negative  \n#> 5 \"the others in the series were great, and i … 1         negative\n\ntoc()\n#> 4.82 sec elapsed\n```\n:::\n\n\nThe analysis took about 10 seconds on my laptop, so around 2 seconds per record.\nThat may not seem like much, but during model, or workflow, development having\nto wait this long every time will take its toll on our time, and patience.\n\nThe new cache folder now has the 5 records cached in their corresponding \nJSON files\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir_ls(\"_performance_cache\", recurse = TRUE, type = \"file\")\n#> _performance_cache/25/25c7c5ad43ce8bd1ddcde3cc42ca7654.json\n#> _performance_cache/65/650dca9d230ae7d29a1fc8a75d396f96.json\n#> _performance_cache/9a/9a5c0290995daac12d35b4286e0cc397.json\n#> _performance_cache/9f/9f2758bfb2295f5eda43691155ae78d5.json\n#> _performance_cache/b7/b7cb11d895428583a067ba17bf6121b1.json\n```\n:::\n\n\nRe-running the same exact call will not take a fraction of a fraction of the\noriginal time!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntic()\n\ndata_bookReviews |>\n  head(5) |>\n  llm_sentiment(review)\n#> # A tibble: 5 × 3\n#>   review                                        sentiment .sentiment\n#>   <chr>                                         <fct>     <chr>     \n#> 1 \"i got this as both a book and an audio file… 1         negative  \n#> 2 \"this book places too much emphasis on spend… 1         negative  \n#> 3 \"remember the hollywood blacklist? the holly… 2         positive  \n#> 4 \"while i appreciate what tipler was attempti… 1         negative  \n#> 5 \"the others in the series were great, and i … 1         negative\n\ntoc()\n#> 0.01 sec elapsed\n```\n:::\n\n\nRunning an additional record, will only cost the time it takes to process it.\nThe other 5 will still be scored using their cached result\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntic()\n\ndata_bookReviews |>\n  head(6) |>\n  llm_sentiment(review)\n#> # A tibble: 6 × 3\n#>   review                                        sentiment .sentiment\n#>   <chr>                                         <fct>     <chr>     \n#> 1 \"i got this as both a book and an audio file… 1         negative  \n#> 2 \"this book places too much emphasis on spend… 1         negative  \n#> 3 \"remember the hollywood blacklist? the holly… 2         positive  \n#> 4 \"while i appreciate what tipler was attempti… 1         negative  \n#> 5 \"the others in the series were great, and i … 1         negative  \n#> 6 \"a few good things, but she's lost her edge … 1         negative\n\ntoc()\n#> 0.346 sec elapsed\n```\n:::\n\n\n## Set the seed!\n\nIf at the end of your analysis, you plan to re-run all of the code, and you\nwant to take advantage of the caching functionaly, then set the model seed. This\nwill allow for the exact same results to be returned by the LLM.\n\nIf no seed is set during development, then the results will always come back \nthe same because the cache is being read. But once the cache is removed, to run \neverything from 0, then you will get different results. This is because the \ninvariability of the cache results, mask the fact that the model will have \nvariability. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nllm_use(\"ollama\", \"llama3.1\", seed = 999)\n#> \n#> ── mall session object\n#> Backend: ollama\n#> LLM session:\n#>   model:llama3.1\n#> \n#>   seed:999\n#> \n#> R session: cache_folder:_performance_cache\n```\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}